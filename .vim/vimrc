" so $VIM/vimrc
"so $VIMRUNTIME/defaults.vim
set nocompatible
if (!has("nvim"))
set viminfofile=$HOME/.vim/viminfo
endif

if has('gui_running')
	set belloff=all
	set guioptions-=L
	set guioptions-=T
	set guioptions-=m
	set guioptions-=r
	let g:netrw_liststyle=3
	" colorscheme slate
	colorscheme default
	set guifont=Bitstream\ Vera\ Sans\ Mono\ 10
endif

" Should be bg& to let it determine itself and done automatically, but that is broken
set background=dark

set sessionoptions=blank,buffers,curdir,folds,help,tabpages,winpos,winsize,resize,terminal
set splitbelow
set splitright
set winminheight=0
set winminwidth=0
set number
set relativenumber
set ruler
set wildmenu
set wildoptions=pum " Vertical wild menu in cmdline
set showcmd
set lazyredraw
set scrolloff=8
set timeout
set timeoutlen=1000
set ttimeout
set ttimeoutlen=0
set mouse=n
set hidden

filetype plugin indent on

set tabstop=2
set shiftwidth=2
" set softtabstop=2
set expandtab
set incsearch
set hlsearch
set noundofile
set noswapfile
set nobackup
set encoding=utf-8
set completeopt=menu,menuone,preview,noinsert
syntax enable

if (!has("nvim"))
set laststatus=2 " Statusline
set statusline=%!MyStatusLine()
set tabline=%!MyTabLine() " Tabline
let g:tabline_diagnostics=0
hi TabLine cterm=reverse " Tabline colors for tty
endif



"TabLine        xxx term=underline cterm=reverse ctermfg=15 ctermbg=242 gui=underline guibg=DarkGrey

"TabLineFill    xxx term=reverse cterm=reverse gui=reverse

"TabLineSel     xxx term=bold cterm=bold gui=bold

" =FUNCTIONS====================
function! GetDiagnostics(id)
  if (exists('*lsp#internal#diagnostics#state#_get_diagnostics_count_for_buffer'))
    return lsp#internal#diagnostics#state#_get_diagnostics_count_for_buffer(a:id)
  endif
  return {'information': 0, 'hint': 0, 'warning': 0, 'error': 0}
endfunction

function! GetDiagnosticsString(table, color)
  let s = ''
  if (a:table.information)
    let s .= s == '' ? '' : a:color.' '
    let s .= 'I'.a:table.information
  endif
  if (a:table.hint)
    let s .= s == '' ? '' : a:color.' '
    let s .= 'H'.a:table.hint
  endif
  if (a:table.warning)
    let s .= s == '' ? '' : a:color.' '
    let s .= '%#Todo#W'.a:table.warning
  endif
  if (a:table.error)
    let s .= s == '' ? '' : a:color.' '
    let s .= '%#Error#E'.a:table.error
  endif
  return s
endfunction

function! MyTabLine()
  let s = ''
  let s .= '%#TabLineSel#'
  let s .= ' '

  for i in range(tabpagenr('$'))
    let n = (i + 1)
    let color = n == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
    let buflist = tabpagebuflist(n)
    let fullname = bufname(buflist[tabpagewinnr(n) - 1])
    let filename = fnamemodify(fullname, ':t')

    " Diagnostics calculation
    let diagnosticsstring = ''
    if (exists('g:tabline_diagnostics') && g:tabline_diagnostics)
      let d = {'information': 0, 'hint': 0, 'warning': 0, 'error': 0}
      for bufnr in buflist
        let tmp = GetDiagnostics(bufnr)
        let d.information += tmp.information
        let d.hint += tmp.hint
        let d.warning += tmp.warning
        let d.error += tmp.error
      endfor
      let diagnosticsstring = GetDiagnosticsString(d, color)
    endif

    " Begin tab
    let s .= '%' . n . 'T'

    let s .= color
    let s .= ' '
    " Tab number
    let s .= ''.n.'.'

    "let s .= '['
    "let s .= tabpagewinnr(a:n, '$')
    "let s .= '] '

    let s .= color

    " Filename
    let s .= filename == '' ? ' [No Name] ' : ' '.pathshorten(fnamemodify(fullname, ":~:.")).' '

    " Diagnostics
    let s .= diagnosticsstring
    let s .= color
    let s .= diagnosticsstring == '' ? '' : ' '

    " Modified indicator
    let modified = 0
    for bufnr in buflist
      if getbufvar(bufnr, '&modified')
        let modified = 1
        break
      endif
    endfor
    if (modified)
      let s .= '[+]'
    else
      let s .= ''
    endif
    let s .= ' '

    " Separator
    let s .= '%#TabLineSel#'
    "let s .= n != tabpagenr('$') ? ' ' : ''
    let s .= ' '
  endfor

  " Rest of the line
  let s .= '%T%#TabLineFill#'
  if tabpagenr('$') > 1
    let s .= '%=;)'
  endif

  return s
endfunction

" Switch source and header files
function! SwitchSourceHeader(force)
  let extension = expand("%:e")
  let fullpath = expand('%:p:r')

  " CPP
  if (extension == "cpp")
    if (filereadable(fullpath.'.hpp'))
      exe 'edit '.fullpath.'.hpp'
    elseif (filereadable(fullpath.'.h') || a:force)
      exe 'edit '.fullpath.'.h'
    endif
  " C
  elseif (extension == "c")
    if (filereadable(fullpath.'.h') || a:force)
      exe 'edit '.fullpath.'.h'
    endif
  " H
  elseif (extension == "h")
    if (filereadable(fullpath.'.c'))
      exe 'edit '.fullpath.'.c'
    elseif (filereadable(fullpath.'.cpp') || a:force) " assume cpp file
      exe 'edit '.fullpath.'.cpp'
    endif
  " HPP
  elseif (extension == "hpp")
    if (filereadable(fullpath.'.cpp') || a:force)
      exe 'edit '.fullpath.'.cpp'
    endif
  else
    echo "Can not switch source/header: not a source/header file."
  endif
endfunction
"map <F4> :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>

" Statusline
function! MyStatusLine()
  let d = exists("g:tabline_diagnostics" && g:tabline_diagnostics) ? GetDiagnosticsString(GetDiagnostics(winbufnr(g:statusline_winid)), '') : ''
  let s = "%<%f ".d."%*
    \%h%m%r %=
    \%( %{&fenc != '' ? &fenc . ' /' : ''}%)
    \%( %{%&ff != '' ? get({'unix':'U','dos':'D','mac':'M'}, &ff) . ' /' : ''%}%)
    \%( %{&ft != '' ? &ft . ' /':''}%)
    \%(  %l:%c%V%)  %P"
  return s
endfunction

" Close empty nameless buffers
function! CleanNoNameEmptyBuffers()
" TODO make it so this does not close them on other tabs
    let buffers = filter(range(1, bufnr('$')), 'buflisted(v:val) 
      \ && empty(bufname(v:val)) && empty(win_findbuf(v:val))
      \ && (getbufline(v:val, 1, "$") == [""])')
    if !empty(buffers)
        exe 'bd '.join(buffers, ' ')
    else
        echo 'No buffer deleted'
    endif
endfunction

" =KEYBINDS=====================
let mapleader=" "

if (!has("nvim"))
" Terminal fuckery (needs to be rebound to avoid waiting for timeout on <esc>)
set <A-h>=h
set <A-j>=j
set <A-k>=k
set <A-l>=l

set <A-1>=1
set <A-2>=2
set <A-3>=3
set <A-4>=4
set <A-5>=5
set <A-6>=6
set <A-7>=7
set <A-8>=8
set <A-9>=9
set <A-n>=n
set <A-p>=p
set <A-f>=f
set <A-e>=e
endif

map Q gq
sunmap Q

" Funny stuff
nnoremap <silent> <esc> :silent noh<CR>
nnoremap <leader> <Nop>

" Change marks
"nnoremap <Space><Space> /<++><CR>c4l
"nnoremap <leader>m i<++><Esc>l

" Configuring
nnoremap <leader>r :so $MYVIMRC<CR>
nnoremap <leader>E :tabnew $MYVIMRC<CR>

" C++ helpers
"nnoremap <leader>inc a#include 
"nnoremap <leader>ifn a#ifndef <++><CR>#define <++><CR>#endif<Esc>?<++><CR>n<C-v>j3lc

" Window navigation
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Window resize
nnoremap <silent> <A-h> :vertical resize -2<CR>
nnoremap <silent> <A-j> :resize +2 <CR>
nnoremap <silent> <A-k> :resize -2 <CR>
nnoremap <silent> <A-l> :vertical resize +2<CR>

" Fullscreen window
nnoremap <A-f> <c-w>_<c-w>\|
nnoremap <A-e> <c-w>=

" Buffers
nnoremap <leader>b :ls<CR>:b<Space>
nnoremap <leader>D :ls<CR>:bd<Space>
nnoremap <leader>n :bnext<CR>
nnoremap <leader>p :bprev<CR>
nnoremap <leader>x :bd<CR>
nnoremap <leader>X :bd!<CR>
nnoremap <leader>e :enew<CR>
nnoremap <leader><Tab> <C-^>

" Tabs
nnoremap <leader>tn :tabnew<CR>
nnoremap <leader>te :tabedit<Space>
nnoremap <leader>tx :tabclose<CR>

nnoremap <A-1> 1gt
nnoremap <A-2> 2gt
nnoremap <A-3> 3gt
nnoremap <A-4> 4gt
nnoremap <A-5> 5gt
nnoremap <A-6> 6gt
nnoremap <A-7> 7gt
nnoremap <A-8> 8gt
nnoremap <A-9> 9gt

nnoremap <silent> <leader>tm1 :tabmove 0<CR>
nnoremap <silent> <leader>tm2 :tabmove 2<CR>
nnoremap <silent> <leader>tm3 :tabmove 3<CR>
nnoremap <silent> <leader>tm4 :tabmove 4<CR>
nnoremap <silent> <leader>tm5 :tabmove 5<CR>
nnoremap <silent> <leader>tm6 :tabmove 6<CR>
nnoremap <silent> <leader>tm7 :tabmove 7<CR>
nnoremap <silent> <leader>tm8 :tabmove 8<CR>
nnoremap <silent> <leader>tm9 :tabmove 9<CR>

" Terminal fixes
tnoremap <C-x> <C-\><C-n>
tnoremap <C-w> <C-w>.
tnoremap <C-\>" <C-w>"
tnoremap <C-\><C-x> <C-x>

" Movement in insert mode
inoremap <C-h> <left>
inoremap <C-j> <down>
inoremap <C-k> <up>
inoremap <C-l> <right>

" Moving lines
nnoremap <A-n> :m .+1<cr>==
nnoremap <A-p> :m .-2<cr>==
vnoremap <A-n> :m '>+1<cr>gv=gv
vnoremap <A-p> :m '<-2<cr>gv=gv

" Matching pairs
if (!has("nvim")) " nvim has plugin for this
inoremap <s-tab> <nop>
inoremap " ""<C-G>U<left>
inoremap "<esc> "<esc>
inoremap <S-tab>" "
inoremap "" ""

inoremap ' ''<C-G>U<left>
inoremap '<esc> '<esc>
inoremap <S-tab>' '
inoremap '' ''

inoremap ( ()<C-G>U<left>
inoremap (<esc> (<esc>
inoremap <S-tab>( (
inoremap () ()

inoremap [ []<C-G>U<left>
inoremap [<esc> [<esc>
inoremap <S-tab>[ [
inoremap [] []

inoremap { {}<C-G>U<left>
inoremap {<esc> {<esc>
inoremap <S-tab>{ {
inoremap {} {}

inoremap < <><C-G>U<left>
inoremap <<esc> <<esc>
inoremap <S-tab>< <
inoremap <<Space> < 
inoremap <= <=
inoremap << <<
endif

nnoremap <silent> <leader>s :call SwitchSourceHeader(0)<CR>
nnoremap <silent> <leader>S :call SwitchSourceHeader(1)<CR>

" =AUTOCOMMANDS=================
if (has("nvim"))|finish|endif " everything after this is plugin specific

" Restore cursor position
aug vimStartup
  au!
  au BufReadPost *
    \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
    \ |   exe "normal! g`\""
    \ | endif
aug END

" Plugins
call plug#begin('~/.vim/plugged')
Plug 'tpope/vim-commentary'
Plug 'xuhdev/vim-latex-live-preview', {'for': 'tex'}
Plug 'iamcco/markdown-preview.nvim', { 'do': 'cd app && yarn install', 'for': ['markdown', 'vim-plug']}
Plug 'prabirshrestha/vim-lsp'
Plug 'aklt/plantuml-syntax'
call plug#end()

" vim-lsp
if executable('clangd')
  aug lsp_clangd
    au!
    au User lsp_setup call lsp#register_server({
          \ 'name': 'clangd',
          \ 'cmd': {server_info->['clangd']},
          \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp'],
          \ })
    autocmd FileType c,cpp,objc,objcpp setlocal omnifunc=lsp#complete
  aug end
endif

function! s:on_lsp_buffer_enabled() abort
    let g:tabline_diagnostics=1
    setlocal omnifunc=lsp#complete
    if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
    nnoremap <buffer> gd <plug>(lsp-definition)
    nnoremap <buffer> gD <plug>(lsp-declaration)
    nnoremap <buffer> gr <plug>(lsp-references)
    nnoremap <buffer> gi <plug>(lsp-implementation)
    "nmap <buffer> gt <plug>(lsp-type-definition)
    "nmap <buffer> gs <plug>(lsp-document-symbol-search)
    "nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
    nnoremap <buffer> <leader>ca <plug>(lsp-code-action)
    nnoremap <buffer> <leader>cr <plug>(lsp-rename)
    nnoremap <buffer> [g <plug>(lsp-previous-diagnostic)
    nnoremap <buffer> ]g <plug>(lsp-next-diagnostic)
    nnoremap <buffer> K <plug>(lsp-hover)
    nnoremap <buffer> <leader>fm <plug>(lsp-document-format)
    inoremap <buffer> <C-s> <C-o><plug>(lsp-signature-help)
    nnoremap <buffer> <expr><c-d> lsp#document_hover_preview_winid() ? lsp#scroll(+4):'<C-d>'
    nnoremap <buffer> <expr><c-u> lsp#document_hover_preview_winid() ? lsp#scroll(-4):'<C-u>'
    "inoremap <buffer> <expr><c-d> lsp#document_hover_preview_winid() ? lsp#scroll(+4):'<C-d>'
    "inoremap <buffer> <expr><c-u> lsp#document_hover_preview_winid() ? lsp#scroll(-4):'<C-u>'
endfunction
aug lsp_install
    au!
    " call s:on_lsp_buffer_enabled only for languages that has the server registered.
    au User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
aug END
let g:lsp_diagnostics_virtual_text_align = 'after'
"let g:lsp_diagnostics_virtual_text_wrap = 'truncate'
"let g:lsp_inlay_hints_mode = {
"\  'normal': ['curline'],
"\}

" vim-markdown
let g:vim_markdown_new_list_item_indent = 0
let g:mkdp_auto_close = 0

" Hexokinase
let g:Hexokinase_ftEnabled = []
let g:Hexokinase_highlighters = [ 'sign_column', 'background', 'backgroundfull', 'foreground', 'foregroundfull' ]

let g:Hexokinase_optInPatterns = [ 'full_hex', 'triple_hex', 'rgb', 'rgba', 'hsl', 'hsla', 'colour_names' ]

let g:vim_markdown_folding_disabled=1
